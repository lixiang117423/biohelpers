% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pca_analysis.R
\name{pca_analysis}
\alias{pca_analysis}
\title{Perform Principal Component Analysis (PCA) with Comprehensive Visualization}
\usage{
pca_analysis(
  data,
  sample,
  n.components = 5,
  scale.data = TRUE,
  center.data = TRUE,
  x.axis = "PC1",
  y.axis = "PC2",
  color.by = "group",
  shape.by = NULL,
  plot.type = "all",
  conf.ellipses = FALSE,
  ellipse.level = 0.95
)
}
\arguments{
\item{data}{Numeric data frame or matrix where rows represent samples (observations)
and columns represent variables (features/genes/metabolites). Missing values
are allowed and will be handled through imputation or exclusion. All variables
should be numeric; categorical variables should be excluded or encoded separately}

\item{sample}{Data frame containing sample metadata with at least one column
matching the row names of the data matrix. Must include:
\itemize{
  \item Sample identifiers that match data row names
  \item Grouping variables for visualization (e.g., treatment, condition, species)
  \item Optional covariates for interpretation
}}

\item{n.components}{Maximum number of principal components to calculate and
return (default: 5). Should be <= min(n_samples-1, n_variables). More
components provide more detailed analysis but increase computation time}

\item{scale.data}{Logical indicating whether to scale variables to unit variance
(default: TRUE). Recommended when variables have different units or scales.
Set to FALSE if data is already standardized or when preserving original scales}

\item{center.data}{Logical indicating whether to center variables to zero mean
(default: TRUE). Almost always recommended for PCA analysis}

\item{x.axis}{Principal component for X-axis in score plot (default: "PC1").
Can be "PC1", "PC2", "PC3", etc., up to the number of calculated components}

\item{y.axis}{Principal component for Y-axis in score plot (default: "PC2").
Should be different from x.axis for meaningful 2D visualization}

\item{color.by}{Column name in sample metadata for point colors (default: "group").
Used to visualize sample groupings or experimental conditions}

\item{shape.by}{Column name in sample metadata for point shapes (default: same as color.by).
Can be the same as color.by or different to show additional sample attributes}

\item{plot.type}{Type of plots to generate (default: "all"). Options:
\itemize{
  \item "all": Generate all available plots
  \item "scores": Only sample score plots
  \item "loadings": Only variable loading plots
  \item "variance": Only variance explanation plots
  \item "none": No plots (results only)
}}

\item{conf.ellipses}{Logical indicating whether to add confidence ellipses
around groups in score plots (default: FALSE). Useful for visualizing
group separation and overlap}

\item{ellipse.level}{Confidence level for ellipses (default: 0.95). Only
used when conf.ellipses = TRUE}
}
\value{
A named list containing comprehensive PCA results:
  \describe{
    \item{\code{pca_model}}{Complete PCA model object from FactoMineR package}
    \item{\code{eigenvalues}}{Data frame with eigenvalue analysis:
      \itemize{
        \item \code{component}: Principal component names (PC1, PC2, ...)
        \item \code{eigenvalue}: Eigenvalue for each component
        \item \code{variance_percent}: Percentage of variance explained
        \item \code{cumulative_percent}: Cumulative variance explained
      }}
    \item{\code{sample_scores}}{Data frame with sample coordinates on principal components:
      \itemize{
        \item \code{sample_id}: Sample identifiers
        \item \code{PC1, PC2, ...}: Principal component scores
        \item All columns from sample metadata for grouping/coloring
      }}
    \item{\code{variable_loadings}}{Data frame with variable contributions:
      \itemize{
        \item \code{variable}: Variable names
        \item \code{PC1, PC2, ...}: Loading values on each component
        \item \code{cos2_PC1, cos2_PC2, ...}: Quality of representation
      }}
    \item{\code{plots}}{List of ggplot2 objects (when plot.type != "none"):
      \itemize{
        \item \code{score_plot}: Sample scores with grouping
        \item \code{scree_plot}: Variance explained by each component
        \item \code{loading_plot}: Variable loadings visualization
        \item \code{biplot}: Combined scores and loadings plot
        \item \code{contribution_plot}: Variable contributions to components
      }}
    \item{\code{summary_stats}}{List with key summary statistics:
      \itemize{
        \item \code{total_variance_explained}: Sum of first n components
        \item \code{kaiser_criterion}: Components with eigenvalue > 1
        \item \code{broken_stick}: Components above broken stick model
      }}
  }
}
\description{
This function performs Principal Component Analysis (PCA) on high-dimensional
data and provides comprehensive results including eigenvalue analysis, sample
scores, variable loadings, and multiple visualization options. PCA is an
unsupervised dimensionality reduction technique that identifies the directions
of maximum variance in the data, making it essential for exploratory data
analysis in genomics, metabolomics, and other omics fields.
}
\details{
\strong{PCA Workflow:}
\enumerate{
  \item Data preprocessing (centering and optional scaling)
  \item Covariance/correlation matrix calculation
  \item Eigenvalue decomposition to find principal components
  \item Sample projection onto component space
  \item Variable loading calculation
  \item Variance explanation analysis
}

\strong{Interpretation Guidelines:}
\itemize{
  \item \strong{Eigenvalues}: Components with eigenvalue > 1 are typically retained
  \item \strong{Variance explained}: First 2-3 components usually explain 50-80% of variance
  \item \strong{Sample scores}: Show relationships between samples in reduced space
  \item \strong{Variable loadings}: Indicate which variables contribute to each component
  \item \strong{Cos2 values}: Quality of variable representation (0-1, higher is better)
}

\strong{Data Requirements:}
\itemize{
  \item Numeric variables only (continuous or discrete)
  \item Sample size >> number of variables (for stable results)
  \item Consider removing low-variance variables
  \item Handle missing values appropriately
}
}
\note{
\itemize{
  \item PCA assumes linear relationships between variables
  \item Results are sensitive to outliers; consider robust PCA for outlier-prone data
  \item Scaling is crucial when variables have different units or ranges
  \item For large datasets, consider approximate PCA methods for computational efficiency
  \item Interpretation requires domain knowledge of the variables and samples
}
}
\examples{
library(biohelpers)
library(dplyr)
library(ggplot2)

# Example 1: Basic PCA analysis with iris data
# Prepare data and sample information
iris_data <- iris[, 1:4]  # Numeric variables only
iris_samples <- data.frame(
  sample_id = paste0("sample_", 1:nrow(iris)),
  species = iris$Species,
  sepal_size = cut(iris$Sepal.Length, breaks = 3, labels = c("Small", "Medium", "Large"))
)
rownames(iris_data) <- iris_samples$sample_id

# Perform PCA analysis
pca_results <- pca_analysis(
  data = iris_data,
  sample = iris_samples,
  color.by = "species"
)

# View variance explained
print("Variance explained by each component:")
print(pca_results$eigenvalues)

# Display score plot
print(pca_results$plots$score_plot)

# Check summary statistics
print(paste("Total variance in first 2 PCs:", 
            round(pca_results$summary_stats$total_variance_explained[2], 1), "\%"))

# Example 2: Customized PCA with different visualization options
pca_custom <- pca_analysis(
  data = iris_data,
  sample = iris_samples,
  n.components = 3,           # Calculate 3 components
  x.axis = "PC1",             # X-axis component
  y.axis = "PC3",             # Y-axis component (skip PC2)
  color.by = "species",       # Color by species
  shape.by = "sepal_size",    # Shape by sepal size
  conf.ellipses = TRUE,       # Add confidence ellipses
  ellipse.level = 0.95        # 95\% confidence ellipses
)

print("Customized PCA plot (PC1 vs PC3):")
print(pca_custom$plots$score_plot)

# Example 3: Metabolomics-style analysis with scaling options
\dontrun{
# Simulate metabolomics data
set.seed(123)
metabolite_data <- matrix(
  rlnorm(50 * 20, meanlog = 5, sdlog = 1),  # Log-normal distribution typical of metabolomics
  nrow = 50, ncol = 20,
  dimnames = list(
    paste0("Sample_", 1:50),
    paste0("Metabolite_", 1:20)
  )
)

metabolite_samples <- data.frame(
  sample_id = rownames(metabolite_data),
  treatment = rep(c("Control", "Treatment_A", "Treatment_B"), length.out = 50),
  batch = rep(c("Batch1", "Batch2"), length.out = 50),
  timepoint = rep(c("T0", "T1", "T2", "T3", "T4"), each = 10)
)

# PCA with scaling (important for metabolomics)
metabolomics_pca <- pca_analysis(
  data = metabolite_data,
  sample = metabolite_samples,
  scale.data = TRUE,          # Scale for different metabolite ranges
  color.by = "treatment",
  shape.by = "timepoint",
  plot.type = "all"
)

# Check for batch effects
batch_plot <- metabolomics_pca$sample_scores \%>\%
  ggplot(aes(x = PC1, y = PC2, color = batch, shape = treatment)) +
  geom_point(size = 3) +
  labs(title = "PCA: Batch Effect Assessment") +
  theme_minimal()

print(batch_plot)
}

# Example 4: Variable importance and loading analysis
# Examine which variables contribute most to PC1 and PC2
variable_importance <- pca_results$variable_loadings \%>\%
  mutate(
    PC1_importance = abs(PC1),
    PC2_importance = abs(PC2),
    total_importance = sqrt(PC1^2 + PC2^2)
  ) \%>\%
  arrange(desc(total_importance))

print("Variables most important for PC1-PC2 space:")
print(head(variable_importance, 10))

# Create custom loading plot
loading_plot <- variable_importance \%>\%
  ggplot(aes(x = PC1, y = PC2)) +
  geom_segment(aes(xend = 0, yend = 0), 
               arrow = arrow(length = unit(0.3, "cm"))) +
  geom_text(aes(label = variable), vjust = -1) +
  labs(
    title = "PCA Loading Plot",
    subtitle = "Variable contributions to PC1 and PC2",
    x = "PC1 Loading",
    y = "PC2 Loading"
  ) +
  theme_minimal() +
  coord_equal()

print(loading_plot)

# Example 5: Quality assessment and component selection
# Scree plot analysis for component selection
scree_analysis <- pca_results$eigenvalues \%>\%
  mutate(
    above_kaiser = eigenvalue > 1,  # Kaiser criterion
    component_num = row_number()
  )

print("Component selection criteria:")
print(scree_analysis)

# Enhanced scree plot with selection criteria
enhanced_scree <- scree_analysis \%>\%
  ggplot(aes(x = component_num, y = variance_percent)) +
  geom_line(color = "blue", size = 1) +
  geom_point(aes(color = above_kaiser), size = 3) +
  geom_hline(yintercept = 100/ncol(iris_data), 
             linetype = "dashed", color = "red",
             alpha = 0.7) +
  labs(
    title = "Scree Plot with Selection Criteria",
    subtitle = "Red line: Average variance per component",
    x = "Principal Component",
    y = "Variance Explained (\%)",
    color = "Above Kaiser\nCriterion"
  ) +
  theme_minimal()

print(enhanced_scree)

# Example 6: Sample quality assessment using PCA
# Identify potential outliers based on PCA scores
sample_distances <- pca_results$sample_scores \%>\%
  mutate(
    pc_distance = sqrt(PC1^2 + PC2^2),  # Distance from origin
    is_outlier = pc_distance > quantile(pc_distance, 0.95)  # Top 5\% as outliers
  )

outlier_plot <- sample_distances \%>\%
  ggplot(aes(x = PC1, y = PC2, color = species, shape = is_outlier)) +
  geom_point(size = 3) +
  scale_shape_manual(values = c(16, 17), name = "Potential\nOutlier") +
  labs(title = "PCA Outlier Detection") +
  theme_minimal()

print(outlier_plot)

# Summary of outliers
outlier_summary <- sample_distances \%>\%
  filter(is_outlier) \%>\%
  select(sample_id, species, PC1, PC2, pc_distance)

if (nrow(outlier_summary) > 0) {
  print("Potential outlier samples:")
  print(outlier_summary)
}

# Example 7: Comparative PCA (with and without scaling)
\dontrun{
# Compare scaled vs unscaled PCA
pca_unscaled <- pca_analysis(
  data = iris_data,
  sample = iris_samples,
  scale.data = FALSE,
  color.by = "species",
  plot.type = "scores"
)

pca_scaled <- pca_analysis(
  data = iris_data,
  sample = iris_samples,
  scale.data = TRUE,
  color.by = "species",
  plot.type = "scores"
)

# Compare variance explained
scaling_comparison <- data.frame(
  Component = 1:2,
  Unscaled_PC1_PC2 = pca_unscaled$eigenvalues$variance_percent[1:2],
  Scaled_PC1_PC2 = pca_scaled$eigenvalues$variance_percent[1:2]
)

print("Scaling effect on variance explained:")
print(scaling_comparison)

# Side-by-side plot comparison
library(gridExtra)
grid.arrange(
  pca_unscaled$plots$score_plot + ggtitle("Unscaled PCA"),
  pca_scaled$plots$score_plot + ggtitle("Scaled PCA"),
  ncol = 2
)
}

}
\references{
Jolliffe, I.T. and Cadima, J. (2016). Principal component analysis: a review and
recent developments. Philosophical Transactions of the Royal Society A, 374(2065), 20150202.

Husson, F., et al. (2010). FactoMineR: An R Package for Multivariate Exploratory
Data Analysis and Data Mining. Journal of Statistical Software, 25(1), 1-18.
}
\seealso{
\itemize{
  \item \code{\link{opls_analysis}} for supervised multivariate analysis
  \item \code{\link{cor_analysis}} for correlation-based analysis
  \item \code{\link[FactoMineR]{PCA}} for underlying PCA implementation
  \item \code{\link[factoextra]{fviz_pca_ind}} for advanced PCA visualization
}
}
